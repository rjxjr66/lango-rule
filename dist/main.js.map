{"version":3,"sources":["webpack:///webpack/bootstrap 8b0455efb765e477fb23","webpack:///./src/index.ts","webpack:///./src/tree.ts","webpack:///external \"xml-js\"","webpack:///./src/rule.interface.ts"],"names":[],"mappings":"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","file":"dist/main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8b0455efb765e477fb23","export * from \"./tree\";\nexport * from \"./rule.interface\";\n\nexport const LANGO_RULE_VERSION = 'v0.0.33'\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import { INode, IXMLNode, IRule, IDependency, ICommand, POS } from \"./rule.interface\";\nimport * as convert from \"xml-js\";\n\nconst relRegExp = new RegExp(\"\\\\{|\\\\}\", \"g\")\nconst invertRegExp = new RegExp(\"^\\\\!\", \"g\")\nexport class Tree {\n    private _curNode: INode;\n    private _curIndex: number;\n\n    constructor(private _tree) {\n        this.reset();\n    }\n\n    buildParent(parent: INode, cur: any) {\n        cur.parent = parent;\n        for (let node of cur.children) {\n            this.buildParent(cur, node);\n        }\n    }\n\n    static fromJSON(json) {\n        const tree = new Tree(json.rootNode);\n\n        // build parent\n        Tree.loopNode(tree._curNode, (node) => {\n            const nodeTokens = [];\n            for (let child of node.children) {\n                child.parent = node\n                child.tokens && nodeTokens.push(child.tokens)\n            }\n\n            node.tokens = node.pos\n            if (node.token) node.tokens += `=${node.token.lemma}`\n            if (nodeTokens.length)\n                node.tokens += `(${nodeTokens.join(\"+\")})`\n        })\n        // tree.buildParent(null, tree._curNode);\n\n        return tree;\n    }\n\n    static fromNode(node: INode) {\n        return new Tree(node);\n    }\n\n    // 트리를 xml 로 변환한다.\n    toXML(): string {\n        var options = {\n            compact: false,\n            ignoreComment: true, spaces: 4,\n            doctypeFn: (val) => {\n                return val.toUpperCase();\n            },\n            cdataFn: val => {\n                return val;\n            },\n            instructionFn: (val) => {\n                return val;\n            },\n            instructionNameFn: val => {\n                return val;\n            },\n            elementNameFn: val => {\n                return val;\n            },\n            attributeNameFn: val => {\n                return val;\n            },\n            attributeValueFn: val => {\n                return val;\n            },\n            attributesFn: val => {\n                return val;\n            },\n            fullTagEmptyElementFn: val => {\n                return val;\n            }\n        }\n\n        const form = {\n            declaration: {\n                attributes: {\n                    version: \"1.0\",\n                    encoding: \"utf-8\"\n                }\n            },\n            elements: []\n        }\n\n        const json = Object.assign({}, this._tree).children[0];\n        Tree.loopNode(json, (node) => {\n            const element: IXMLNode = { type: \"\" };\n\n            // leaf node\n            if (!(node.children && node.children.length)) {\n                if (node.word) {\n                    element[\"type\"] = \"text\";\n                    element[\"text\"] = node.word\n                } else {\n                    element[\"type\"] = \"element\";\n                    element[\"name\"] = node.element;\n                }\n            }\n            // non-leaf node\n            else {\n                element[\"type\"] = \"element\";\n                if (!element.elements) element.elements = [];\n\n                for (let child of node.children) {\n                    // 띄어쓰기 추가\n                    if (child.element.type === \"text\" && element.elements.length)\n                        child.element.text = \" \" + child.element.text\n                    element.elements.push(child.element);\n                }\n\n                if (node.parent && node.parent.pos === \"ROOT\") {\n                    element[\"name\"] = \"sentence\"\n                } else if (node.element) {\n                    element[\"name\"] = node.element;\n                } else {\n                    if (element.elements.filter(child => child.type === \"text\").length)\n                        element[\"name\"] = \"word\"\n                    else if (element.elements.filter(child => [\"word\", \"chunk\"].includes(child[\"name\"])).length)\n                        element[\"name\"] = \"part\"\n                    else\n                        element[\"name\"] = \"chunk\"\n                }\n            }\n            if (node.attr) element[\"attributes\"] = node.attr\n            node.element = element;\n        })\n        form.elements.push(json.element)\n\n        // const result = convert.json2xml(JSON.parse(JSON.stringify({ sentence: this.toJSON() })), options);\n        const result = convert.json2xml(JSON.stringify(form), options);\n        return result;\n    }\n\n    root() {\n        return this._tree\n    }\n\n    // 노드 포인터를 루트노드로 옮긴다.\n    reset() {\n        this._curNode = this._tree;\n        if (this._curNode.parent) {\n            this._curIndex = this._curNode.parent.children.findIndex(_ => _ === this._curNode)\n        } else {\n            this._curIndex = 0;\n        }\n    }\n\n\n    // search2(rule: IRule, dependencies: IDependency[] = [], curNode: INode = null): INode {\n    //     if (curNode) this._setCurrent(curNode);\n    //     else this.reset();\n\n    //     const ruleTokens = Tree._getTokens(rule.match);\n    //     // const matches = this._loopMatchNode(this._curNode, rule, Tree._getTokens(rule.match));\n\n    //     return null;\n    // }\n\n    // 패턴과 매칭되는 노드를 선택한다.\n    // 선택된 노드를 현재 노드로 설정하고 매칭된 노드가 없으면 null 을 리턴한다.\n    search(rule: IRule, dependencies: IDependency[] = [], curNode: INode = null): INode {\n        if (curNode) this._setCurrent(curNode);\n        else this.reset();\n\n        if (!rule.relations) {\n            rule.relations = [];\n        }\n\n        // relation의 OR조건\n        for (let relation of rule.relations) {\n            relation.references = dependencies.filter(dep =>\n                relation.relation.split(\"|\").includes(dep.dep));\n        }\n\n        const match = this._loopMatchNode(this._curNode, rule, Tree._getTokens(rule.match));\n        if (match) {\n            this._setCurrent(match);\n\n            if (!match.matchRules) match.matchRules = [];\n            match.matchRules.push(rule);\n\n            return match;\n        } else {\n            return null;\n        }\n    }\n\n    // Tree 전체 Node들을 초기화한다.\n    init() {\n        this.reset();\n        this.initNode(this._curNode);\n    }\n\n    // 하위 node들을 돌면서 저장된 matchRules을 초기화시킨다.\n    initNode(node: INode) {\n        if (node.matchRules && node.matchRules.length) node.matchRules = [];\n        for (let child of node.children) {\n            this.initNode(child);\n        }\n    }\n\n\n    // 커맨드를 적용한다.\n    static apply(node: INode, commands: ICommand[]) {\n        for (let command of commands) {\n            switch (command.cmd) {\n                case 'MOVE':\n                    Tree._move(node, command.args)\n                    break;\n                case 'DELETE':\n                    Tree._delete(node, command.args)\n                    break;\n                case 'CREATE':\n                    Tree._create(node, command.args)\n                    break;\n                case 'SET':\n                    Tree._set(node, command.args)\n                    break;\n                case 'REPLACE':\n                    Tree._replace(node, command.args)\n                    break;\n                case 'ELEMENT':\n                    Tree._element(node, command.args)\n                    break;\n                case 'WORD':\n                    Tree._word(node, command.args)\n                    break;\n                case 'MERGE':\n                    Tree._merge(node, command.args)\n                    break;\n            }\n        }\n    }\n\n    // 현재 노드를 리턴한다.\n    cur() {\n        return this._curNode;\n    }\n\n    // 부모 노드로 이동하고 리턴한다. 실패시 null\n    // TODO : 실패시 현재 노드 그대로는 어떨지? (지호)\n    parent(): INode {\n        if (this._curNode.parent) {\n            return this._setCurrent(this._curNode.parent);\n        } else {\n            return null;\n        }\n    }\n\n    // 다음 형제노드로 이동하고 리턴한다. 실패시 null\n    // TODO : 실패시 현재 노드 그대로는 어떨지? (지호)\n    nextSibiling(): INode {\n        if (this._curNode.parent) {\n            const nextIndex = this._curIndex + 1;\n            if (nextIndex <= this._curNode.parent.children.length - 1) {\n                this._curIndex = nextIndex;\n                this._curNode = this._curNode.parent.children[nextIndex];\n\n                return this._curNode;\n            } else {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    // 이전 형제노드로 이동하고 리턴한다. 실패시 null\n    // TODO : 실패시 현재 노드 그대로는 어떨지? (지호)\n    prevSibiling(): INode {\n        if (this._curNode.parent) {\n            const prevIndex = this._curIndex - 1;\n            if (prevIndex >= 0) {\n                this._curIndex = prevIndex;\n                this._curNode = this._curNode.parent.children[prevIndex];\n\n                return this._curNode;\n            } else {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    // 자식 노드로 이동\n    // TODO : 실패시 현재 노드 그대로는 어떨지? (지호)\n    child(): INode {\n        if (this._curNode.children.length) {\n            this._curNode = this._curNode.children[0];\n            this._curIndex = 0;\n\n            return this._curNode;\n        } else {\n            return null;\n        }\n    }\n\n    // 트리를 LL로 돌면서 매칭되는 노드가 있는지 순회\n    private _loopMatchNode(node: INode, rule: IRule, tokens: string[]): INode {\n        let matched;\n        if (node.matchRules && node.matchRules.includes(rule)) {\n            matched = { match: false };\n        } else {\n            matched = this._matchRule(node, tokens);\n        }\n\n        if (matched.match) {\n            if (rule.relations && rule.relations.length && matched.relArgs) {\n                const passed = rule.relations.filter(relation => {\n                    if (relation.governor) {\n                        if (!matched.relArgs[relation.governor]) return false;\n                    }\n                    if (relation.dependent) {\n                        if (!matched.relArgs[relation.dependent]) return false;\n                    }\n\n                    const found = relation.references.find(ref => {\n                        if (relation.governor && !Tree._findRefNode(\n                            matched.relArgs[relation.governor],\n                            {\n                                index: ref.governor,\n                                lemma: ref.governorGloss\n                            }))\n                            return false;\n\n                        if (relation.dependent && !Tree._findRefNode(\n                            matched.relArgs[relation.dependent],\n                            {\n                                index: ref.dependent,\n                                lemma: ref.dependentGloss\n                            }))\n                            return false;\n                        return true;\n                    })\n                    return !!found;\n                });\n                if (passed.length === rule.relations.length) return node;\n            } else return node;\n        }\n\n        if (node.children) {\n            for (let _node of node.children) {\n                const match = this._loopMatchNode(_node, rule, tokens);\n                if (match) {\n                    return match;\n                }\n            }\n        } else {\n            return null;\n        }\n    }\n\n    // Node내에 해당 릴레이션 정보를 가진 하위 Node를 찾는다.\n    private static _findRefNode(node: INode, ref: { index: number, lemma: string }) {\n        if (node.token && node.token.index === ref.index && node.token.lemma === ref.lemma)\n            return node;\n\n        if (node.children) {\n            for (let child of node.children) {\n                if ([\"S\", \"SBAR\"].includes(child.pos)) continue;\n                const ret = Tree._findRefNode(child, ref);\n                if (ret) return ret;\n            }\n        }\n        return null;\n    }\n\n    // Node와 RuleNode가 매칭되는지 확인한다. (같은 Depth의 regex로 검색)\n    // ex) S (NP (PRP)) (VP (VBP) (SBAR (...))) 와 S(*+VP(*+[SBAR|...]+*))\n    // 일때 S와 S, NP+VP와 *+VP+*, VBP+SBAR와 *+SBAR+* 단계로 검색\n    private _matchRule(node: INode, tokens: string[]) {\n        const relArgs = {};\n        const tree = Tree.fromNode(node);\n        let star = false;\n\n        let checkNext = false;\n        for (let token of tokens) {\n            let cur = null;\n\n            // 다음 노드가 없을 때 * 이 아니면 false\n            if (checkNext) {\n                if (token != '*') {\n                    return { match: false };\n                } else {\n                    checkNext = false;\n                }\n            }\n\n            switch (token) {\n                case '(':\n                    cur = tree.child();\n                    star = false;\n                    break;\n                case ')':\n                    cur = tree.parent();\n                    star = false;\n                    break;\n                case '+':\n                    if (!star) cur = tree.nextSibiling()\n                    break;\n                case '*':\n                    star = true;\n                    break;\n                default:\n                    const _node = token.split('=');\n                    const _token = _node[0].split('|');\n                    let lemmas = [], rels = [];\n\n                    if (_node[1]) {\n                        for (let query of _node[1].split(\"|\")) {\n                            if (query.match(relRegExp)) {\n                                rels.push(query.replace(relRegExp, \"\"));\n                            } else {\n                                lemmas.push(query);\n                            }\n                        }\n                    }\n\n                    // 이전 토큰이 * 인경우\n                    if (star) {\n                        star = false;\n\n                        // 노드가 나올때까지 다음 노드로 이동\n                        do {\n                            if (_token.includes(tree._curNode.pos)) {\n                                // relation 변수 등록\n                                for (let rel of rels) {\n                                    relArgs[rel] = tree._curNode\n                                }\n\n                                if (lemmas.length) {\n                                    let include = false;\n                                    for (let _lemma of lemmas) {\n                                        if (_lemma.match(invertRegExp)) {\n                                            if (tree._curNode.token.lemma !== _lemma.replace(invertRegExp, \"\")) {\n                                                include = true;\n                                                break;\n                                            }\n                                        } else {\n                                            if (tree._curNode.token.lemma === _lemma) {\n                                                include = true;\n                                                break;\n                                            }\n                                        }\n                                    }\n\n                                    if (!include) continue;\n                                }\n\n                                cur = tree._curNode;\n                                break; // 노드가 검색됨\n                            }\n                        } while (tree.nextSibiling())\n\n                        if (!cur) {\n                            return { match: false };\n                        }\n                    } else {\n                        // 이전 토큰이 * 이 아닌경우 노드가 반드시 일치해야 함\n                        if (!_token.includes(tree._curNode.pos)) {\n                            return { match: false };\n                        } else {\n                            // relation 변수 등록\n                            for (let rel of rels) {\n                                relArgs[rel] = tree._curNode\n                            }\n                            if (lemmas.length && !lemmas.includes(tree._curNode.token.lemma)) {\n                                return { match: false };\n                            }\n\n                            cur = tree._curNode;\n                        }\n                    }\n                    break;\n            }\n\n            // 형제나 다음 노드가 없을 때\n            if (!cur && !star) {\n                if (token == '+') {\n                    // 형제가 없을 때 다음 토큰이 * 인지 검사해야 함\n                    checkNext = true;\n                } else {\n                    // 자식, 부모, 해당 노드가 없을 때\n                    return { match: false };\n                }\n            }\n        }\n\n        return { relArgs, match: true };\n    }\n\n    private static _getTokens(match: string): string[] {\n        let tokens = [];\n        let token = '';\n        for (let c of match) {\n            if ('()+[]'.includes(c)) {\n                if (token) {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                tokens.push(c);\n            } else {\n                token += c;\n            }\n        }\n\n        if (token) {\n            tokens.push(token);\n        }\n        // let tokens = match.match(tokenRegexp);\n        return tokens;\n    }\n\n    private _setCurrent(node: INode): INode {\n        this._curNode = node;\n        this._setCurrentIndex();\n\n        return this._curNode;\n    }\n\n    private _setCurrentIndex(): number {\n        if (this._curNode.parent) {\n            return this._curIndex = this._curNode.parent.children.findIndex(_ => _ == this._curNode);\n        } else {\n            return this._curIndex = 0;\n        }\n    }\n\n    public static select(node: INode, arg: string): INode[] {\n        const tree = Tree.fromNode(node);\n        const tokens = Tree._getTokens(arg);\n        const selection: INode[] = [];\n\n        let shouldStartSelection = false;\n        let shouldEndSelection = false;\n\n        let selectStartIdx = -1;\n        let selectEndIdx = -1;\n        let lastToken = null;\n        for (let token of tokens) {\n            switch (token) {\n                case '(':\n                    tree.child();\n                    break;\n                case ')':\n                    if (shouldEndSelection) {\n                        selectEndIdx = tree._curNode.parent.children.length;\n                        if (selectStartIdx >= 0 && selectEndIdx >= 0)\n                            selection.push(...(tree._curNode.parent.children.slice(selectStartIdx, selectEndIdx)))\n                        shouldEndSelection = false;\n                    }\n                    tree.parent();\n                    break;\n                case '+':\n                    if (lastToken !== \"*\") {\n                        tree.nextSibiling()\n                    }\n                    break;\n                case '*':\n                    lastToken = token;\n                    break;\n                case '[':\n                    if (lastToken === \"*\") {\n                        shouldStartSelection = true;\n                    } else {\n                        selectStartIdx = tree._curIndex;\n                    }\n                    break;\n                case ']':\n                    if (lastToken === \"*\") {\n                        shouldEndSelection = true;\n                    } else {\n                        selectEndIdx = tree._curIndex + 1;\n                        if (selectStartIdx >= 0 && selectEndIdx >= 0)\n                            selection.push(...(tree._curNode.parent.children.slice(selectStartIdx, selectEndIdx)))\n                    }\n                    break;\n                default:\n                    lastToken = token;\n                    let nodes = token.split('|');\n\n                    do {\n                        if (nodes.includes(tree._curNode.pos)) {\n                            if (shouldStartSelection) {\n                                selectStartIdx = tree._curIndex;\n                                shouldStartSelection = false;\n                            }\n                            if (shouldEndSelection) {\n                                selectEndIdx = tree._curIndex + 1;\n                                if (selectStartIdx >= 0 && selectEndIdx >= 0)\n                                    selection.push(...(tree._curNode.parent.children.slice(selectStartIdx, selectEndIdx)))\n                                shouldEndSelection = false;\n                            }\n                            break;\n                        }\n                    } while (tree.nextSibiling())\n                    break;\n            }\n        }\n\n        return selection;\n    }\n\n    public static move(source: INode[], target: INode, method: string = \"push\") {\n        // 삭제\n        let tmp = [...source];\n        for (let node of tmp) {\n            node.parent.children.splice(node.parent.children.findIndex(_ => _ == node), 1);\n            node.parent = target;   // parent가 업데이트됨\n        }\n\n        // 삽입\n        if (method === 'push') {\n            target.children.push(...tmp);\n        } else {\n            target.children.unshift(...tmp);\n        }\n    }\n\n    private static _move(node: INode, args: string[]) {\n        const source = Tree.select(node, args[0]);\n        const target = Tree.select(node, args[1])[0];\n        Tree.move(source, target, args[2])\n    }\n\n    public static delete(node: INode, recursive: boolean = false) {\n        const parent = node.parent;\n        // \b전체제거\n        if (recursive) {\n            parent.children.splice(parent.children.findIndex(_ => _ == node), 1);\n        }\n        // 타겟만 제거\n        else {\n            parent.children.splice(parent.children.findIndex(_ => _ == node), 1, ...node.children);\n\n            // 부모변경\n            for (let child of node.children) {\n                child.parent = parent;\n            }\n        }\n    }\n\n    private static _delete(node: INode, args: string[]) {\n        const target = Tree.select(node, args[0])[0];\n        Tree.delete(target, args[1] === \"true\")\n    }\n\n    public static create(node: INode, pos: string, method: string = \"push\") {\n        const newNode = {\n            pos,\n            parent: node,\n            children: [],\n            word: \"\"\n        }\n\n        // 삽입\n        if (method === 'push') {\n            node.children.push(<INode>newNode);\n        } else {\n            node.children.unshift(<INode>newNode);\n        }\n    }\n\n    private static _create(node: INode, args: string[]) {\n        const target = Tree.select(node, args[0])[0];\n        Tree.create(target, args[1], args[2]);\n        // const method = args[2] || 'push';\n\n        // const newNode = {\n        //     pos: args[1],\n        //     parent: target,\n        //     children: [],\n        //     word: \"\"\n        // }\n        // // 삽입\n        // if (method === 'push') {\n        //     target.children.push(<INode>newNode);\n        // } else {\n        //     target.children.unshift(<INode>newNode);\n        // }\n    }\n\n    public static set(node: INode, attrName: string, attrVal: string) {\n        if (!node.attr) {\n            node.attr = {}\n        }\n\n        node.attr[attrName] = attrVal;\n    }\n\n    private static _set(node: INode, args: string[]) {\n        const target = Tree.select(node, args[0])[0];\n        Tree.set(target, args[1], args[2]);\n    }\n\n    public static replace(node: INode, pos: string) {\n        node.pos = pos as POS;\n    }\n\n    private static _replace(node: INode, args: string[]) {\n        const target = Tree.select(node, args[0])[0];\n        Tree.replace(target, args[1])\n    }\n\n    public static element(node: INode, element: string) {\n        // // WORD 엘리먼트로 확정된 상태에서 다른 ELEMENT의 룰이 중복 선언되면 하위에 WORD를 생성후에 현재 노드에 ELEMENT를 부여한다\n        // if (node.element && node.element !== element) {\n        //     const clone = Object.assign({}, node);\n        //     clone.parent = node;\n        //     node.children = [clone];\n        //     node.attr = {}\n        // }\n        node.element = element;\n    }\n\n    private static _element(node: INode, args: string[]) {\n        const target = Tree.select(node, args[0])[0];\n        Tree.element(target, args[1])\n    }\n\n    public static word(node: INode, word: string) {\n        let curNode = node;\n\n        // 해당 노드의 최하위(leaf) 노드를 선택\n        while (curNode.children && curNode.children.length) {\n            curNode = curNode.children[0]\n        }\n\n        curNode.word = word;\n        let token = Object.assign({}, curNode.token);\n        token.lemma = word;\n        curNode.token = token;\n\n    }\n\n    private static _word(node: INode, args: string[]) {\n        const target = Tree.select(node, args[0])[0];\n        Tree.word(target, args[1])\n    }\n\n    // TODO merge 만들기\n    private static _merge(node: INode, args: string[]) {\n    }\n\n    public static loopNode(node: INode, cb: Function = null) {\n        for (let child of node.children) {\n            Tree.loopNode(child, cb);\n        }\n        cb && cb(node);\n    }\n\n    public toJSON() {\n        const jsonObj = Object.assign({}, this._tree);\n        Tree.loopNode(jsonObj, (node) => {\n            delete node.parent;\n        })\n        return jsonObj;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tree.ts","module.exports = require(\"xml-js\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"xml-js\"\n// module id = 2\n// module chunks = 0","export type POS = 'S' | 'SBAR' | 'NP' | 'VP' | 'ADJP' | 'ADVP' | 'PP' | 'WHNP' | 'WHADJP' | 'WHAVP' | 'WHPP' | 'IN' | 'CC' | 'TO' | 'EX' | 'WDT' |\n    'WP' | 'WP$' | 'WRB' | 'NN' | 'NNS' | 'NNP' | 'NNPS' | 'PRP' | 'VB' | 'VBP' | 'VBZ' | 'MD' | 'PRT' | 'JJ' | 'JJR' | 'JJS' | 'DT' | 'PRP$' |\n    'CD' | 'VBG' | 'VBN' | 'RB' | 'RBS' | 'NP-TMP';\n\n\nexport interface IRule {\n    name?: string;\n    match: string; // 자식관계는 (), 형제관계는 +, lemma는 =\n    tokens?: string[];\n    commands: ICommand[];\n    relations?: IRelation[]; // 관계 패턴\n    // apply: Function;\n}\n\n/*******\n* Rule 작성 예시\nS(\n    VP(\n        *+NP|S|PP|SBAR|ADJP|ADVP+*\n    )\n)\n********/\n\nexport interface ICommand {\n    cmd: ECommand;\n    tree?: ICommandNode;\n    args?: string[]; // 피연산자(타겟 노드). Rule 작성 규칙을 따르되 선택할 노드는 [], match 된 트리 중 root 노드 기준으로 작성\n}\n/*******\n* Command 작성 예시 - NP|S|PP|SBAR|ADJP|ADVP 이후의 노드들을 모두 S 로 연결\n{\n    cmd: ECommand.MOVE,\n    args: [\n        `\n        S(\n            VP(\n                *+[NP|S|PP|SBAR|ADJP|ADVP+*]\n            )\n        )\n        `,\n        `\n        [S]\n        `\n    ]\n}\n********/\n\n\nexport interface IRelation {\n    relation?: string; // ex1) nmod, ex2) nsubj|nsubjpass\n    governor?: string; // 검색 패턴으로 선택\n    dependent?: string; // 검색 패턴으로 선택\n    references?: IDependency[]  // 관계관련 의존성들\n}\n\nexport interface INode {\n    pos: POS;\n    parent: INode;\n    children: INode[];\n    word: string;\n    token: IToken;\n    nodeTokens?: string;\n    matchRules: IRule[];\n    attr: any;\n    element: string;\n}\n\nexport interface IDependency {\n    dep: string;\n    governor: number;\n    governorGloss: string;\n    dependent: number;\n    dependentGloss: string;\n}\n\nexport interface IToken {\n    index?: number;\n    lemma?: string;\n}\n\nexport interface ICommandNode {\n    tokens: string[];\n    parent: ICommandNode;\n    children?: ICommandNode[];\n    sources?: string[]\n}\n\nexport enum ECommand {\n    DELETE = \"DELETE\",\n    MOVE = \"MOVE\",\n    CREATE = \"CREATE\",\n    SET = \"SET\",\n    REPLACE = \"REPLACE\",\n    ELEMENT = \"ELEMENT\",\n    MERGE = \"MERGE\",\n    WORD = \"WORD\"\n}\n\n\nexport interface IXMLNode {\n    type: string;\n    attributes?: Object;\n    text?: string;\n    elements?: Array<IXMLNode>;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/rule.interface.ts"],"sourceRoot":""}