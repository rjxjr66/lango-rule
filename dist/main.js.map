{"version":3,"sources":["webpack:///webpack/bootstrap 333b062a5352eed6140a","webpack:///./src/index.ts","webpack:///./src/tree.ts","webpack:///./src/rule.interface.ts"],"names":[],"mappings":"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","file":"dist\\main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 333b062a5352eed6140a","export * from \"./tree\";\r\nexport * from \"./rule.interface\";\r\n\r\nexport const LANGO_RULE_VERSION = 'v0.0.25'\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import { INode, IRule, IDependency, ICommand, POS } from \"./rule.interface\";\r\n\r\nexport class Tree {\r\n    private _curNode: INode;\r\n    private _curIndex: number;\r\n\r\n    constructor(private _tree) {\r\n        this.reset();\r\n    }\r\n\r\n    buildParent(parent: INode, cur: any) {\r\n        cur.parent = parent;\r\n        for (let node of cur.children) {\r\n            this.buildParent(cur, node);\r\n        }\r\n    }\r\n\r\n    static fromJSON(json) {\r\n        const tree = new Tree(json.rootNode);\r\n        tree.buildParent(null, tree._curNode);\r\n\r\n        return tree;\r\n    }\r\n\r\n    static fromNode(node: INode) {\r\n        return new Tree(node);\r\n    }\r\n\r\n    // 트리를 xml 로 변환한다.\r\n    toXML(): string {\r\n\r\n        return null;\r\n    }\r\n\r\n    root() {\r\n        return this._tree\r\n    }\r\n\r\n    // 노드 포인터를 루트노드로 옮긴다.\r\n    reset() {\r\n        this._curNode = this._tree;\r\n        if (this._curNode.parent) {\r\n            this._curIndex = this._curNode.parent.children.findIndex(_ => _ === this._curNode)\r\n        } else {\r\n            this._curIndex = 0;\r\n        }\r\n    }\r\n\r\n    mergeRuleWithRelation(rule) {\r\n\r\n    }\r\n    // 패턴과 매칭되는 노드를 선택한다.\r\n    // 선택된 노드를 현재 노드로 설정하고 매칭된 노드가 없으면 null 을 리턴한다.\r\n    search(rule: IRule, dependencies: IDependency[] = [], curNode: INode = null): INode {\r\n        if (curNode) this._setCurrent(curNode);\r\n        else this.reset();\r\n\r\n        const _dependencies = dependencies.filter(dep => {\r\n            return rule.relations.filter(_ => _.relation === dep.dep).length\r\n        })\r\n        // for (let relation of rule.relations) {\r\n        //     const _dep = dependencies.find(_ => _.dep === relation.relation);\r\n        //     if (_dep) {\r\n        //         relation.governorIdx = _dep.governor;\r\n        //         relation.dependentIdx = _dep.dependent;\r\n        //     }\r\n        // }\r\n        // rule.relations.map(relation => {\r\n        //     const _dep = dependencies.find(_ => _.dep === relation.relation);\r\n        //     let ret = { ...relation };\r\n        //     if (_dep) ret = Object.assign(ret, {\r\n        //         governorIdx: _dep.governor,\r\n        //         dependentIdx: _dep.dependent\r\n        //     })\r\n        //     return ret;\r\n        // })\r\n        const match = this._loopMatchNode(this._curNode, rule, Tree._getTokens(rule.match));\r\n        if (match) {\r\n            this._setCurrent(match);\r\n\r\n            if (!match.matchRules) match.matchRules = [];\r\n            match.matchRules.push(rule);\r\n\r\n            return match;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Tree 전체 Node들을 초기화한다.\r\n    init() {\r\n        this.reset();\r\n        this.initNode(this._curNode);\r\n    }\r\n\r\n    // 하위 node들을 돌면서 저장된 matchRules을 초기화시킨다.\r\n    initNode(node: INode) {\r\n        if (node.matchRules && node.matchRules.length) node.matchRules = [];\r\n        for (let child of node.children) {\r\n            this.initNode(child);\r\n        }\r\n    }\r\n\r\n\r\n    // 커맨드를 적용한다.\r\n    static apply(node: INode, commands: ICommand[]) {\r\n        for (let command of commands) {\r\n            switch (command.cmd) {\r\n                case 'MOVE':\r\n                    Tree._move(node, command.args)\r\n                    break;\r\n                case 'DELETE':\r\n                    Tree._delete(node, command.args)\r\n                    break;\r\n                case 'CREATE':\r\n                    Tree._create(node, command.args)\r\n                    break;\r\n                case 'SET':\r\n                    Tree._set(node, command.args)\r\n                    break;\r\n                case 'REPLACE':\r\n                    Tree._replace(node, command.args)\r\n                    break;\r\n                case 'ELEMENT':\r\n                    Tree._element(node, command.args)\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // 현재 노드를 리턴한다.\r\n    cur() {\r\n        return this._curNode;\r\n    }\r\n\r\n    // 부모 노드로 이동하고 리턴한다. 실패시 null\r\n    // TODO : 실패시 현재 노드 그대로는 어떨지? (지호)\r\n    parent(): INode {\r\n        if (this._curNode.parent) {\r\n            return this._setCurrent(this._curNode.parent);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // 다음 형제노드로 이동하고 리턴한다. 실패시 null\r\n    // TODO : 실패시 현재 노드 그대로는 어떨지? (지호)\r\n    nextSibiling(): INode {\r\n        if (this._curNode.parent) {\r\n            const nextIndex = this._curIndex + 1;\r\n            if (nextIndex <= this._curNode.parent.children.length - 1) {\r\n                this._curIndex = nextIndex;\r\n                this._curNode = this._curNode.parent.children[nextIndex];\r\n\r\n                return this._curNode;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // 이전 형제노드로 이동하고 리턴한다. 실패시 null\r\n    // TODO : 실패시 현재 노드 그대로는 어떨지? (지호)\r\n    prevSibiling(): INode {\r\n        if (this._curNode.parent) {\r\n            const prevIndex = this._curIndex - 1;\r\n            if (prevIndex >= 0) {\r\n                this._curIndex = prevIndex;\r\n                this._curNode = this._curNode.parent.children[prevIndex];\r\n\r\n                return this._curNode;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // 자식 노드로 이동\r\n    // TODO : 실패시 현재 노드 그대로는 어떨지? (지호)\r\n    child(): INode {\r\n        if (this._curNode.children.length) {\r\n            this._curNode = this._curNode.children[0];\r\n            this._curIndex = 0;\r\n\r\n            return this._curNode;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // 트리를 LL로 돌면서 매칭되는 노드가 있는지 순회\r\n    private _loopMatchNode(node: INode, rule: IRule, tokens: string[]): INode {\r\n        if (node.matchRules && node.matchRules.includes(rule)) {\r\n            return null;\r\n        } else if (this._matchRule(node, tokens)) {\r\n            return node;\r\n        } else {\r\n            if (node.children) {\r\n                for (let _node of node.children) {\r\n                    const match = this._loopMatchNode(_node, rule, tokens);\r\n                    if (match) {\r\n                        return match;\r\n                    }\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Node와 RuleNode가 매칭되는지 확인한다. (같은 Depth의 regex로 검색)\r\n    // ex) S (NP (PRP)) (VP (VBP) (SBAR (...))) 와 S(*+VP(*+[SBAR|...]+*))\r\n    // 일때 S와 S, NP+VP와 *+VP+*, VBP+SBAR와 *+SBAR+* 단계로 검색\r\n    private _matchRule(node: INode, tokens: string[]): boolean {\r\n        const tree = Tree.fromNode(node);\r\n        let star = false;\r\n\r\n        let checkNext = false;\r\n        for (let token of tokens) {\r\n            let cur = null;\r\n\r\n            // 다음 노드가 없을 때 * 이 아니면 false\r\n            if (checkNext) {\r\n                if (token != '*') {\r\n                    return false;\r\n                } else {\r\n                    checkNext = false;\r\n                }\r\n            }\r\n\r\n            switch (token) {\r\n                case '(':\r\n                    cur = tree.child();\r\n                    star = false;\r\n                    break;\r\n                case ')':\r\n                    cur = tree.parent();\r\n                    star = false;\r\n                    break;\r\n                case '+':\r\n                    cur = tree.nextSibiling()\r\n                    break;\r\n                case '*':\r\n                    star = true;\r\n                    break;\r\n                default:\r\n                    const node = token.split('=');\r\n                    const _token = node[0].split('|');\r\n                    const lemma = node[1];\r\n\r\n                    // 이전 토큰이 * 인경우\r\n                    if (star) {\r\n                        star = false;\r\n\r\n                        // 노드가 나올때까지 다음 노드로 이동\r\n                        do {\r\n                            if (_token.includes(tree._curNode.pos)) {\r\n                                if (lemma && lemma != tree._curNode.token.lemma) {\r\n                                    continue;\r\n                                }\r\n                                cur = tree._curNode;\r\n                                break; // 노드가 검색됨\r\n                            }\r\n                        } while (tree.nextSibiling())\r\n\r\n                        if (!cur) {\r\n                            return false;\r\n                        }\r\n                    } else {\r\n                        // 이전 토큰이 * 이 아닌경우 노드가 반드시 일치해야 함\r\n                        if (!_token.includes(tree._curNode.pos)) {\r\n                            return false;\r\n                        } else {\r\n                            if (lemma && lemma != tree._curNode.token.lemma) {\r\n                                return false;\r\n                            }\r\n                            cur = tree._curNode;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            // 형제나 다음 노드가 없을 때\r\n            if (!cur && !star) {\r\n                if (token == '+') {\r\n                    // 형제가 없을 때 다음 토큰이 * 인지 검사해야 함\r\n                    checkNext = true;\r\n                } else {\r\n                    // 자식, 부모, 해당 노드가 없을 때\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private static _getTokens(match: string): string[] {\r\n        let tokens = [];\r\n        let token = '';\r\n        for (let c of match) {\r\n            if ('()+[]'.includes(c)) {\r\n                if (token) {\r\n                    tokens.push(token);\r\n                    token = '';\r\n                }\r\n\r\n                tokens.push(c);\r\n            } else {\r\n                token += c;\r\n            }\r\n        }\r\n\r\n        if (token) {\r\n            tokens.push(token);\r\n        }\r\n        // let tokens = match.match(tokenRegexp);\r\n        return tokens;\r\n    }\r\n\r\n    private _setCurrent(node: INode): INode {\r\n        this._curNode = node;\r\n        this._setCurrentIndex();\r\n\r\n        return this._curNode;\r\n    }\r\n\r\n    private _setCurrentIndex(): number {\r\n        if (this._curNode.parent) {\r\n            return this._curIndex = this._curNode.parent.children.findIndex(_ => _ == this._curNode);\r\n        } else {\r\n            return this._curIndex = 0;\r\n        }\r\n    }\r\n\r\n    private static _select(node: INode, arg: string): INode[] {\r\n        const tree = Tree.fromNode(node);\r\n        const tokens = Tree._getTokens(arg);\r\n        const selection: INode[] = [];\r\n\r\n        let shouldStartSelection = false;\r\n        let shouldEndSelection = false;\r\n\r\n        let selectStartIdx = -1;\r\n        let selectEndIdx = -1;\r\n        let lastToken = null;\r\n        for (let token of tokens) {\r\n            switch (token) {\r\n                case '(':\r\n                    tree.child();\r\n                    break;\r\n                case ')':\r\n                    if (shouldEndSelection) {\r\n                        selectEndIdx = tree._curIndex + 1;\r\n                        if (selectStartIdx >= 0 && selectEndIdx >= 0)\r\n                            selection.push(...(tree._curNode.parent.children.slice(selectStartIdx, selectEndIdx)))\r\n                        shouldEndSelection = false;\r\n                    }\r\n                    tree.parent();\r\n                    break;\r\n                case '+':\r\n                    if (lastToken !== \"*\") {\r\n                        tree.nextSibiling()\r\n                    }\r\n                    break;\r\n                case '*':\r\n                    lastToken = token;\r\n                    break;\r\n                case '[':\r\n                    if (lastToken === \"*\") {\r\n                        shouldStartSelection = true;\r\n                    } else {\r\n                        selectStartIdx = tree._curIndex;\r\n                    }\r\n                    break;\r\n                case ']':\r\n                    if (lastToken === \"*\") {\r\n                        shouldEndSelection = true;\r\n                    } else {\r\n                        selectEndIdx = tree._curIndex + 1;\r\n                        if (selectStartIdx >= 0 && selectEndIdx >= 0)\r\n                            selection.push(...(tree._curNode.parent.children.slice(selectStartIdx, selectEndIdx)))\r\n                    }\r\n                    break;\r\n                default:\r\n                    lastToken = token;\r\n                    let nodes = token.split('|');\r\n\r\n                    do {\r\n                        if (nodes.includes(tree._curNode.pos)) {\r\n                            if (shouldStartSelection) {\r\n                                selectStartIdx = tree._curIndex;\r\n                                shouldStartSelection = false;\r\n                            }\r\n                            if (shouldEndSelection) {\r\n                                selectEndIdx = tree._curIndex + 1;\r\n                                if (selectStartIdx >= 0 && selectEndIdx >= 0)\r\n                                    selection.push(...(tree._curNode.parent.children.slice(selectStartIdx, selectEndIdx)))\r\n                                shouldEndSelection = false;\r\n                            }\r\n                            break;\r\n                        }\r\n                    } while (tree.nextSibiling())\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return selection;\r\n    }\r\n\r\n    private static _move(node: INode, args: string[]) {\r\n        const source = Tree._select(node, args[0]);\r\n        const target = Tree._select(node, args[1])[0];\r\n        const method = args[2] || 'push';\r\n\r\n        // 삭제\r\n        let tmp = [...source];\r\n        for (let node of tmp) {\r\n            node.parent.children.splice(node.parent.children.findIndex(_ => _ == node), 1);\r\n            node.parent = target;   // parent가 업데이트됨\r\n        }\r\n\r\n        // 삽입\r\n        if (method === 'push') {\r\n            target.children.push(...tmp);\r\n        } else {\r\n            target.children.unshift(...tmp);\r\n        }\r\n    }\r\n\r\n    private static _delete(node: INode, args: string[]) {\r\n        const target = Tree._select(node, args[0])[0];\r\n        const parent = target.parent;\r\n\r\n        // 교체\r\n        parent.children.splice(parent.children.findIndex(_ => _ == target), 1, ...target.children);\r\n\r\n        // 부모변경\r\n        for (let child of target.children) {\r\n            child.parent = parent;\r\n        }\r\n    }\r\n\r\n    private static _create(node: INode, args: string[]) {\r\n        const target = Tree._select(node, args[0])[0];\r\n        const method = args[2] || 'push';\r\n\r\n        const newNode = {\r\n            pos: args[1],\r\n            parent: node,\r\n            children: [],\r\n            word: \"\"\r\n        }\r\n        // 삽입\r\n        if (method === 'push') {\r\n            target.children.push(<INode>newNode);\r\n        } else {\r\n            target.children.unshift(<INode>newNode);\r\n        }\r\n    }\r\n\r\n    private static _set(node: INode, args: string[]) {\r\n        const target = Tree._select(node, args[0])[0];\r\n        if (!target.attr) {\r\n            target.attr = {}\r\n        }\r\n\r\n        target.attr[args[1]] = args[2];\r\n    }\r\n\r\n    private static _replace(node: INode, args: string[]) {\r\n        const target = Tree._select(node, args[0])[0];\r\n        target.pos = args[1] as POS;\r\n    }\r\n\r\n    private static _element(node: INode, args: string[]) {\r\n        const target = Tree._select(node, args[0])[0];\r\n        target.element = args[1];\r\n    }\r\n\r\n    private loopNode(node: INode, cb: Function = null) {\r\n        cb && cb(node);\r\n        for (let child of node.children) {\r\n            this.loopNode(child, cb);\r\n        }\r\n    }\r\n\r\n    public toJSON() {\r\n        const jsonObj = Object.assign({}, this._tree);\r\n        this.loopNode(jsonObj, (node) => { node.parent = null })\r\n        return jsonObj;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/tree.ts","export type POS = 'S' | 'SBAR' | 'NP' | 'VP' | 'ADJP' | 'ADVP' | 'PP' | 'WHNP' | 'WHADJP' | 'WHAVP' | 'WHPP' | 'IN' | 'CC' | 'TO' | 'EX' | 'WDT' |\r\n    'WP' | 'WP$' | 'WRB' | 'NN' | 'NNS' | 'NNP' | 'NNPS' | 'PRP' | 'VB' | 'VBP' | 'VBZ' | 'MD' | 'PRT' | 'JJ' | 'JJR' | 'JJS' | 'DT' | 'PRP$' |\r\n    'CD' | 'VBG' | 'VBN' | 'RB' | 'RBS' | 'NP-TMP';\r\n\r\n\r\nexport interface IRule {\r\n    name?: string;\r\n    match: string; // 자식관계는 (), 형제관계는 +, lemma는 =\r\n    tokens?: string[];\r\n    commands: ICommand[];\r\n    relations?: IRelation[]; // 관계 패턴\r\n    // apply: Function;\r\n}\r\n\r\n/*******\r\n* Rule 작성 예시\r\nS(\r\n    VP(\r\n        *+NP|S|PP|SBAR|ADJP|ADVP+*\r\n    )\r\n)\r\n********/\r\n\r\nexport interface ICommand {\r\n    cmd: ECommand;\r\n    tree?: ICommandNode;\r\n    args?: string[]; // 피연산자(타겟 노드). Rule 작성 규칙을 따르되 선택할 노드는 [], match 된 트리 중 root 노드 기준으로 작성\r\n}\r\n/*******\r\n* Command 작성 예시 - NP|S|PP|SBAR|ADJP|ADVP 이후의 노드들을 모두 S 로 연결\r\n{\r\n    cmd: ECommand.MOVE,\r\n    args: [\r\n        `\r\n        S(\r\n            VP(\r\n                *+[NP|S|PP|SBAR|ADJP|ADVP+*]\r\n            )\r\n        )\r\n        `,\r\n        `\r\n        [S]\r\n        `\r\n    ]\r\n}\r\n********/\r\n\r\n\r\nexport interface IRelation {\r\n    relation?: string; // ex1) nmod, ex2) nsubj|nsubjpass\r\n    governor?: string; // 검색 패턴으로 선택\r\n    dependent?: string; // 검색 패턴으로 선택\r\n    // governorIdx?: number;\r\n    // dependentIdx?: number;\r\n}\r\n\r\nexport interface INode {\r\n    pos: POS;\r\n    parent: INode;\r\n    children: INode[];\r\n    word: string;\r\n    token: IToken;\r\n    matchRules: IRule[];\r\n    attr: any;\r\n    element: string;\r\n}\r\n\r\nexport interface IDependency {\r\n    dep: string;\r\n    governor: number;\r\n    governorGloss: string;\r\n    dependent: number;\r\n    dependentGloss: string;\r\n}\r\n\r\nexport interface IToken {\r\n    index?: number;\r\n    lemma?: string;\r\n}\r\n\r\nexport interface ICommandNode {\r\n    tokens: string[];\r\n    parent: ICommandNode;\r\n    children?: ICommandNode[];\r\n    sources?: string[]\r\n}\r\n\r\nexport enum ECommand {\r\n    DELETE = \"DELETE\",\r\n    MOVE = \"MOVE\",\r\n    CREATE = \"CREATE\",\r\n    SET = \"SET\",\r\n    REPLACE = \"REPLACE\",\r\n    ELEMENT = \"ELEMENT\",\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/rule.interface.ts"],"sourceRoot":""}